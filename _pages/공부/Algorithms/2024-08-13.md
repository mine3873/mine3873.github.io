---
title: "그래프 이론 - 연결요소의 수"
tags:
    - Algorithms
    - baekjoon
    - Problem Solving
    - Component
date: "2024-08-13"
thumbnail: "https://github.com/user-attachments/assets/bf334ee3-722b-45fd-a823-65e45b4d9513"
---
# 그래프 연결요소의 수 
---
## [1012. 유기농 배추](https://www.acmicpc.net/problem/1012)
### 문제
- - -
차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다. 한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있는 것이다.

한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어 놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다. 예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다. 0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.

1	1	0	0	0	0	0	0	0	0
0	1	0	0	0	0	0	0	0	0
0	0	0	0	1	0	0	0	0	0
0	0	0	0	1	0	0	0	0	0
0	0	1	1	0	0	0	1	1	1
0	0	0	0	1	0	0	1	1	1

- - -

인접해 있는 1의 값들을 하나의 연결 그래프로 인식하여, 전체 좌표를 돌면서 연결요소의 수를 구하면 되는 문제입니다. 
저는 배추밭을 boolean 값의 2차원 배열을 통해 나타내야 겠다고 생각했고, 그 후에 (0,0)에서부터 시작하여 전체 좌표를 순회하면서 dfs를 사용하여 연결 요소의 수를 구하고자 하였습니다.  

#### Code

``` cpp
#include<iostream>
#include<vector>

using namespace std;

bool space[51][51] = {0,}; // 배추 밭
int M, N; // M : 가로 길이, N : 세로 길이

void dfs(int curX, int curY){
    space[curX][curY] = false;
    if(curX + 1 < M && space[curX + 1][curY]){
        dfs(curX + 1, curY);
    }
    if(curX - 1 >= 0 && space[curX - 1][curY]){
        dfs(curX - 1, curY);
    }
    if(curY + 1 < N && space[curX][curY + 1]){
        dfs(curX, curY + 1);
    }
    if(curY - 1 >= 0 && space[curX][curY - 1]){
        dfs(curX, curY - 1);
    }
}

int dfsAll(){
    int components = 0; 
    int curX = 0, curY = 0;
    while(curX < M && curY < N){
        if(space[curX][curY]){ //배추를 발견한 경우, dfs 시작.
            dfs(curX,curY);
            components++;
        }
        if(curX + 1 == M){ //배추밭 순회
            curY++;
            curX = 0;
        }
        else
            curX++;
    }
    return components;
}

int main(){
    int t;
    cin >> t;
    while(t--){
        int K;
        cin >> M >> N >> K;
        while(K--){
            int x,y;
            cin >> x >> y;
            space[x][y] = true;
        }
        cout << dfsAll() << '\n';
    }
    return 0;
}
```
#### Result

| 메모리 | 시간  |
|---|---|
| 2136 KB | 0 ms |

#### Review

코드 실행 시간은 괜찮았지만, 사용된 메모리가 남들에 비해 더 많았습니다.  
그래서 타인의 코드를 가져와서 어떻게 다른지 확인해보겠습니다.  
<mark>여기서 yudai님의 코드를 가져와 보았습니다.</mark> ~~맘대로 해도 되나..~~
- - -
``` cpp
#include <stdio.h>
#include <memory.h>

const int dx[] = { 0,0,-1,1 };
const int dy[] = { -1,1,0,0 };

int tc, n, m, k, i, j, x, y, ans;
bool farm[52][52];

void dfs(int x, int y) {
	farm[x][y] = 0;
	for (int i = 0; i < 4; i++)
		if (farm[x + dx[i]][y + dy[i]]) dfs(x + dx[i], y + dy[i]);
}

int main() {
	scanf("%d", &tc);

	while (tc--) {
		ans = 0, memset(farm, 0, sizeof(farm));
		scanf("%d %d %d", &n, &m, &k);
		while (k--) {
			scanf("%d %d", &x, &y);
			farm[++x][++y] = 1;
		}
		for (i = 1; i <= n; i++)
			for (j = 1; j <= m; j++)
				if (farm[i][j]) ans++, dfs(i, j);
		printf("%d\n", ans);
	}

	return 0;
}
// by yudai
```
- - -

가장 먼저 보인 것은 이 것입니다.  
``` cpp
const int dx[] = { 0,0,-1,1 };
const int dy[] = { -1,1,0,0 };
.
.
if (farm[x + dx[i]][y + dy[i]]) dfs(x + dx[i], y + dy[i]);
//yudai님의 코드

//내 코드
if(curX + 1 < M && space[curX + 1][curY]){
    dfs(curX + 1, curY);
}
if(curX - 1 >= 0 && space[curX - 1][curY]){
    dfs(curX - 1, curY);
}
if(curY + 1 < N && space[curX][curY + 1]){
    dfs(curX, curY + 1);
}
if(curY - 1 >= 0 && space[curX][curY - 1]){
    dfs(curX, curY - 1);
}
```
<mark>저는 위,아래, 양 옆을 확인하기 위해 4개의 if문을 사용하여 처리하였으나, yudai님은 4방향을 dx와 dy 배열으로 나타내고, 반복문을 사용하여 이를 처리하였습니다. </mark>
비교해보면 저의 코드가 좀 더 직관적이고, ~~진짜 조금~~ 메모리를 덜 사용하고 ~~진짜 조오금~~ 코드 실행 시간도 더 적지만, ~~지이이인짜 조금~~ 그 차이가 알 수 없을 정도로 미미하기에 차이는 거의 없다고 봐도 됩니다. 그러나 코드를 수정하는데 있어서 yudai님의 코드는 배열의 값만 조정하면 되기에 유지 보수가 쉽지만, 저의 코드는 그렇지 않다는 단점이 있습니다. 또한 간결하고요.  
그리고 또 눈여겨 볼 점이 있는데,  
<mark>저는 dfs를 진행하면서 현재 (x,y) 좌표가 배추밭 영역을 넘어가 Out Of Range가 발생하지 않도록 조건을 추가하였습니다.  
그러나 yudai님은 그렇지 않았는데,</mark> 코드를 살펴보니 
``` cpp
bool farm[52][52];
.
.
for (i = 1; i <= n; i++)
			for (j = 1; j <= m; j++)
				if (farm[i][j]) ans++, dfs(i, j);
```
이렇게 처리하였습니다.  
여기서 문제에 다음과 같은 조건이 있습니다.  
> 배추밭의 가로길이는 1 이상 50 이하이고, 세로길이는 1이상 50이하이다.

배추밭을 2차원으로 나타낸 변수인 farm의 크기를 배추밭 최대크기보다 2를 더 크게 설정하였습니다.  
그렇게 하면 다음과 같이 되는데,  
|0|0|0|
|---|:---:|---|
|0|배추밭|0|
|0|0|0|

배추밭이 최대크기이더라도 그 테두리를 0으로 한겹 더 감싸져 있으므로, Out Of Range가 발생하지 않는 것이었습니다.  


그리고 마지막으로 볼 것이 c++에서 stdio.h 라이브러리를 사용하는 것인데,  
std::cout / std::cin 방식과 printf / scanf 방식에 차이가 있는가 ? 궁금증이 생겼습니다.  
그래서 std::cout 출력 10000번 하는 것과 printf 출력 10000번을 했을 경우, 속도 차이가 있는지 확인해 보았습니다.
##### std::cout VS. printf
``` cpp
#include<chrono>
#include<iostream>
#include<stdio.h>
#define max 10000
using namespace std;
using namespace chrono;

int main(){
    system_clock::time_point start_time = system_clock::now();
    for(int i = 0; i < max; i++){
        cout << "hello world!" << endl;
    }
    system_clock::time_point end_time = system_clock::now();

    nanoseconds nanoA = end_time - start_time;
    

    start_time = system_clock::now();
    for(int i = 0; i < max; i++){
        printf("hello world!\n");
    }
    end_time = system_clock::now();
    nanoseconds nanoB = end_time - start_time;
    cout << "cout ---\n";
    cout << "time : " << nanoA.count() << " nanoSeconds\n";
    cout << "printf ---\n";
    cout << "time : " << nanoB.count() << " nanoSeconds\n";
}
```
```
cout ---
time : 1272602000 nanoSeconds
printf ---
time : 656128000 nanoSeconds
```
printf 형식이 더 빠른 결과가 나왔습니다.  
std::endl을 없애고 "\n"로 처리한 결과, std::cout 의 속도가 눈에 띄게 줄었지만, 아직 printf에 비해 느렸습니다.  
5번 정도 더 실행해도 결과는 같았습니다.  
다른 차이점이 있는지 찾아보았더니, 어느정도 안정성에 있어서 std::cout 가 더 좋아는 차이점이 있었습니다.  
그리고 printf / scanf 를 사용하는 이유는 앞서 살펴본 속도 차이 때문인데, 이로 인해 PS에서 시간 초과가 나타날 수 있기 때문이라고 합니다.  
그래서 개선 방법이 두가지가 있었습니다. 
> 1. stdio.h 사용
> 2. cin, cout의 속도 높이기

2번 방법의 경우, 다음과 같은 코드를 추가하여 속도를 stdio.h와 비슷하게 올릴 수 있다고 합니다.  
``` cpp
ios::sync_with_stdio(false); 
cin.tie(NULL); 
cout.tie(NULL);
```
하지만 이 경우, stdio.h 의 printf / scanf 등의 입출력 함수를 사용하게 되면 오류가 난다고 하니 되도록이면 1번의 방법을 사용해야 겠습니다.  
~~그 이유는 공부해서 오겠습니다...~~

## [연결 요소의 개수](https://www.acmicpc.net/problem/11724)
### 문제 
방향 없는 그래프가 주어졌을 때, 연결 요소 (Connected Component)의 개수를 구하는 프로그램을 작성하시오.
- - -
위의 배추밭 문제와 같이 그저 연결 요소의 수를 구하여 출력하면 되는 문제입니다. 

~~내일 다시 올께요..~~

### Code
``` cpp

```
## [안전 영역]()
## [섬의 개수]()